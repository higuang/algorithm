package org.yray.pattern.visitor;

/***
 * @author  lyg
 * 访问者模式是一种将数据操作与数据结构分离的设计模式
 * 基本想法是，软件系统中拥有一个由许多对象构成的、比较稳定的对象结构，这些对象的类都拥有一个 accept 方法用来接受访问者对象的访问。访问者是一个接口，它拥有一个 visit 方法，
 * 这个方法对访问到的对象结构中不同类型的元素做出不同的处理。在对象结构的一次访问过程中，我们遍历整个对象结构，对每一个元素都实施 accept 方法，
 * 在每一个元素的 accept 方法中会调用访问者的 visit 方法，从而使访问者得以处理对象结构的每一个元素，我们可以针对对象结构设计不同的访问者类来完成不同的操作，达到区别对待的效果。
 * 定义：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。
 * 可以对定义这么理解：有这么一个操作，它是作用于一些元素之上的，而这些元素属于某一个对象结构。同时这个操作是在不改变各元素类的前提下，在这个前提下定义新操作是访问者模式精髓中的精髓。
 * 使用场景：
 * （1）对象结构比较稳定，但经常需要在此对象结构上定义新的操作。
 * （2）需要对一个对象结构中的对象进行很多不同的且不相关的操作，而需要避免这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。
 * 记住为什么要有这设计模式，核心关键点，保护现有的已经非常稳定的对象结构稳定，遵从核心原则-开闭原则，
 *
 *
 * （1）Visitor：接口或者抽象类，它定义了对每一个元素（Element）访问的行为，它的参数就是可以访问的元素，它的方法数理论上来讲与元素种类是一样的，
 * 因此，访问者模式要求元素的类族要稳定，如果经常添加、移除元素类，必然会导致频繁地修改Visitor接口，如果这样则不适合使用访问者模式。
 * （2）ConcreteVisitor1、ConcreteVisitor2：具体的访问类，它需要给出对每种元素类访问时所产生的具体行为。
 * （3）Element：元素接口或者抽象类，它定义了一个接受访问者的方法（Accept），其意义是指每一个元素都要可以被访问者访问。
 * （4）ConcreteElementA、ConcreteElementB：具体的元素类，它提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。
 * （5）ObjectStructure：定义当中所说的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素供访问者访问。
 *
 * 你可能会说，我为什么要用这设计模式，我可以让对象结构直接提供个获取所有元素的接口，然后想要对元素进行什么样的操作就实现用一个方法来实现这不就行了，
 * 如果你从性能，维护成本，产生BUG概率，资源占用，程序可持续拓展，迭代存活下去方面考虑，你也大可以一个类实现一整个程序
 *
 * 代码示例，呼叫记录，有呼入，呼出类型，记录有接听时间，时长，状态，等待时长,话费
 * 需求一，求呼入总时间，
 * 后面有新增需求，求呼出总时间，
 * 后面又新增需求，求呼出接通总笔数
 * ...
 */
public class ReadMe {
}
