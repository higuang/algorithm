package org.yray.pattern;

/**
 * @author  lyg
 * 设计模式的七大原则的基本概念，
 * 其中包括开闭原则、单一职责原则、里氏替换原则、依赖倒置原则，接口隔离原则、迪米特法则、合成复用原则
 * 1.开闭原则（Open Closed Principle，OCP）由勃兰特・梅耶（Bertrand Meyer）提出，他在 1988 年的著作《面向对象软件构造》（Object Oriented Software Construction）中提出：
 * 软件实体应当对扩展开放，对修改关闭（Software entities should be open for extension，but closed for modification），这就是开闭原则的经典定义。
 * 开闭原则是设计模式中的总原则，开闭原则就是说：对拓展开放、对修改关闭。 模块应该在尽量不修改代码的前提下进行拓展，这就需要使用接口和抽象类来实现预期效果。
 *
 * 2.单一职责原则
 * 单一职责原则，简单得来说就是保证设计类、接口、方法时做到功能单一，权责明确。
 * 单一职责可以降低类的复杂性，提高代码可读性、可维护性
 * 但是用 “职责” 或 “变化原因” 来衡量接口或类设计得是否优良，但是 “职责” 和 “变化原因” 都是不可度量的，因项目、环境而异；指责划分稍微不当，很容易造成资源浪费，代码量增多，
 * 好比微服务时服务边界拆分不清
 *
 * 3.里氏替换原则
 * 里氏替换原则的解释是，所有引用基类的地方必须能透明地使用其子类的对象。 通俗来讲的话，就是说，只要父类能出现的地方子类就可以出现，并且使用子类替换掉父类的话，不会产生任何异常或错误，
 * 使用者可能根本就不需要知道是父类还是子类。反过来就不行了，有子类的地方不一定能使用父类替换。
 * 里氏替换原则是开闭原则的实现基础，它告诉我们设计程序的时候尽可能使用基类进行对象的定义及引用，具体运行时再决定基类对应的具体子类型。
 * 里氏替换可以提高代码复用性，子类继承父类时自然继承到了父类的属性和方法
 * 提高代码可拓展性，子类通过实现父类方法进行功能拓展，个性化定制
 * 里氏替换中的继承有侵入性。继承，就必然拥有父类的属性和方法
 * 增加了代码的耦合性。父类方法或属性的变更，需要考虑子类所引发的变更
 *
 * 4.依赖倒置原则
 * 依赖倒置原则的定义：程序要依赖于抽象接口，不要依赖于具体实现。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。
 * 依赖倒置原则要求我们在程序代码中传递参数时或在关联关系中，尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。
 * 依赖倒置原则，高层模块不应该依赖低层模块，都应该依赖抽象。抽象不应该依赖细节，细节应该依赖抽象。其核心思想是：要面向接口编程，不要面向实现编程。
 * 高层模块不应该依赖低层模块，都应该依赖抽象（接口或抽象类）
 * 接口或抽象类不应该依赖于实现类
 * 实现类应该依赖于接口或抽象类
 *
 * 5.接口隔离原则
 * 接口隔离原则（Interface Segregation Principle，ISP）的定义是客户端不应该依赖它不需要的接口，类间的依赖关系应该建立在最小的接口上。 简单来说就是建立单一的接口，不要建立臃肿庞大的接口。也就是接口尽量细化，同时接口中的方法尽量少，保持接口纯洁性。
 * 我们所讲的接口主要分为两大类，一是实例接口，比如使用 new 关键字产生一种实例，被 new 的类就是实例类的接口。从这个角度出发的话，java 中的类其实也是一种接口。二是类接口，java 中常常使用 interface 关键字定义。
 * 接口尽量粒度化，保持接口纯洁性
 * 接口要高内聚，即减少对外交互
 *
 * 6.迪米特法则
 * 迪米特法则（Law of Demeter，LOD），有时候也叫做最少知识原则（Least Knowledge Principle，LKP），它的定义是：一个软件实体应当尽可能少地与其它实体发生相互作用。迪米特法则的初衷在于降低类之间的耦合。
 * 类定义时尽量内敛，少使用 public 权限修饰符，尽量使用 private、protected 等。
 *
 * 7.合成复用原则
 * 合成复用原则是通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。 原则是尽量首先使用合成 / 聚合的方式，而不是使用继承。
 * 合成和聚合都是关联的特殊种类。合成是值的聚合（Aggregation by Value），而复合是引用的聚合（Aggregation by Reference）。
 * 都知道，类之间有三种基本关系，分别是：关联（聚合和组合）、泛化（与继承同一概念）、依赖。
 * 这里我们提一下关联关系，客观来讲，大千世界中的两个实体之间总是有着千丝万缕的关系，归纳到软件系统中就是两个类之间必然存在关联关系。如果一个类单向依赖另一个类，那么它们之间就是单向关联。如果彼此依赖，则为相互依赖，即双向关联。
 * 关联关系包括两种特例：聚合和组合。聚合，用来表示整体与部分的关系或者 “拥有” 关系。其中，代表部分的对象可能会被代表多个整体的对象所拥有，但是并不一定会随着整体对象的销毁而销毁，部分的生命周期可能会超越整体。好比班级和学生，班级销毁或解散后学生还是存在的，学生可以继续存在某个培训机构或步入社会，生命周期不同于班级甚至大于班级。
 * 合成，用来表示一种强得多的 “拥有” 关系。其中，部分和整体的生命周期是一致的，一个合成的新的对象完全拥有对其组成部分的支配权，包括创建和泯灭。好比人的各个器官组成人一样，一旦某个器官衰竭，人也不复存在，这是一种 “强” 关联。
 * 新对象可以调用已有对象的功能，从而达到对象复用
 *
 * 创建类5种
 * 工厂模式
 * 工厂方法
 * 单例模式
 * 原型
 * 建造者
 *
 * 结构类7种
 * 适配
 * 装饰
 * 代理
 * 组合
 * 外观
 * 桥接
 * 享元模式
 *
 * 行为类11种
 * 策略
 * 模板
 * 观察者
 * 访问者
 * 迭代器
 * 责任链
 * 状态
 * 命令
 * 解释器
 * 中介
 * 备忘录
 */
public class ReadMe {

}
